// Copyright 2023 Ben L. Titzer. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def INITIAL_VALUES = 128;
def INITIAL_FRAMES = 16;

// Implements an interpreter capable of executing all SSA instructions, calls, etc
// for initialization and testing.
class SsaInterpreter(prog: Program, genSsa: (IrSpec, int) -> SsaGraph) {
	var values = Array<Val>.new(INITIAL_VALUES);
	var stack = Array<SsaIntFrame>.new(INITIAL_FRAMES);
	var frame: SsaIntFrame;
	def args = SsaIntArguments.new(prog);
	var sp: int;
	var retVal: Val;
	var exception: Exception;
	var printer: SsaPrinter;
	var tailCalled: bool;

	new() {
		args.interpreter = this;
	}

	def invoke(del: Closure, args: Array<Val>) -> Result {
		frame = null;
		exception = null;
		retVal = null;
		tailCalled = false;
		sp = 0;
		
		pushFrame(del.memberRef, del.val, args);

		// Main execution loop
		while (true) {
			var n = step(frame.ip);
			if (frame == null) break;
			frame.ip = n;
		}
		
		return if (exception == null, retVal, exception);
	}
	def setTrace(on: bool) {
		if (on) printer = SsaPrinter.new();
		else printer = null;
	}
	def step(i: SsaInstr) -> SsaInstr {
		if (printer != null) {
			for (j < sp) printer.buf.puts("  ");
			printer.printInstr(i, false, false, false);
			printer.flush();
		}
		match (i) {
			x: SsaParam => {
				if (printer != null) putEqVal(getVal(x), x.getType());
				return nextInstr(i);
			}
			x: SsaApplyOp => {
				if (printer != null) putInputs(x.inputs);
				var n = nextInstr(x);
				doOp(x);
				if (tailCalled) {
					tailCalled = false;
					return frame.ip;
				}
				return n;
			}
			x: SsaPhi => {
				if (printer != null) putEqVal(getVal(x), x.getType());
				return nextInstr(i);
			}
			x: SsaGoto => {
				if (printer != null) printer.outln();
				return doGoto(x.succs[0]);
			}
			x: SsaIf =>  {
				if (printer != null) putInputs(x.inputs).outln();
				var cond = getVal(x.inputs[0].dest), taken = Bool.unbox(cond);
				var which = if(taken, 0, 1);
				return doGoto(x.succs[which]);
			}
			x: SsaSwitch => {
				if (printer != null) putInputs(x.inputs).outln();
				var key = getVal(x.inputs[0].dest);
				var which = Int.unbox(key);
				if (u32.view(which) > u32.view(x.succs.length)) which = x.succs.length - 1;
				return doGoto(x.succs[which]);
			}
			x: SsaReturn => {
				if (printer != null) {
					putInputs(x.inputs).outln();
					var b = printer.buf;
					for (j < sp) b.puts("  ");
					b.puts("<=");
					printer.outln();
				}
				var r = if(x.inputs.length > 0, getVal(x.inputs[0].dest));
				if (--sp < 1) {
					frame = null;
					retVal = r;
					return null;
				} else {
					frame = stack[sp - 1];
					setVal(frame.ip, r);
					return nextInstr(frame.ip);
				}
			}
			x: SsaThrow => {
				args.throw(x.exception, null);
				if (printer != null) printer.outln();
			}
		}
		return fail("unexpected SsaInstr type");
	}
	private def putEqVal(v: Val, t: Type) {
		printer.buf.puts(" = ");
		printer.buf.puthashv(v, t).ln();
		printer.flush();
	}
	private def putInputs(inputs: Array<SsaDfEdge>) -> SsaPrinter {
		var b = printer.buf;
		b.puts("(");
		for (i < inputs.length) {
			if (i > 0) b.csp();
			var v = inputs[i];
			printer.printRef(v);
			if (!SsaConst.?(v.dest)) {
				b.putc('=').puthashv(getVal(v.dest), null).end();
			}
		}
		b.puts(") ");
		return printer;
	}
	private def getVal(i: SsaInstr) -> Val {
		if (SsaConst.?(i)) return SsaConst.!(i).val;
		if (i.valueNum < 0) allocValueNum(i);
		return values[frame.fp + i.valueNum];
	}
	private def setVal(i: SsaInstr, v: Val) {
		if (i.valueNum < 0) allocValueNum(i);
		var index = frame.fp + i.valueNum;
		if (index >= values.length) values = Arrays.grow(values, frame.meth.ssa.numValues + values.length * 2);
		values[index] = v;
		// TODO: if (Debug.paranoid) do a type check
	}
	private def allocValueNum(i: SsaInstr) {
		var g = frame.meth.ssa;
		i.valueNum = g.numValues++;
		if (frame.fp + g.numValues >= values.length) values = Arrays.grow(values, INITIAL_VALUES + values.length * 2);
	}
	private def doGoto(target: SsaCfEdge) -> SsaInstr {
		var block = frame.block = target.dest;
		for (i = block.next; i != block; i = i.next) {
			match (i) {
				x: SsaPhi => setVal(x, getVal(x.inputs[target.desti].dest));
				x: SsaInstr => return x;
				_ => return fail("no SsaInstr successor");
			}
		}
		return fail("fell off the end of the block");
	}
	private def doOp(i: SsaApplyOp) {
		args.frame = frame;
		args.args = Arrays.grow(args.args, i.inputs.length);
		args.typeArgs = i.op.typeArgs;
		for (j < i.inputs.length) {
			args.args[j] = getVal(i.inputs[j].dest);
		}
		args.nargs = i.inputs.length;
		var r = Eval.doOp(i.op, args);
		match (r) {
			x: Exception => {
				this.exception = x;
				if (printer != null) { printer.buf.put1("= !%s", x.error).ln(); printer.flush(); }
			}
			x: Val => {
				setVal(i, x);
				if (printer != null && !tailCalled) putEqVal(x, i.op.sig.returnType());
			}
			null => {
				setVal(i, null);
				if (printer != null && !tailCalled) putEqVal(null, i.op.sig.returnType());
			}
		}
	}
	private def nextInstr(i: SsaLink) -> SsaInstr {
		var n = i.next;
		if (n == null) return fail("no instruction successor");
		if (!SsaInstr.?(n)) return fail("successor is not an SsaInstr");
		return SsaInstr.!(n);
	}
	private def fail<T>(msg: string) -> T {
		var d: T;
		if (exception == null) {
			var buf = StringBuilder.new().puts(msg);
			if (frame != null) {
				if (frame.ip != null) buf.put1(", near @%d", frame.ip.uid);
				if (frame.block != null) buf.put1(", in block #%d", frame.block.uid);
			}
			exception = Exception.new("SsaEvalInternalError", buf.toString(), getStackTrace());
			if (CLOptions.FATAL.val) System.error(exception.error, exception.msg);
		}
		return d;
	}
	def getStackTrace() -> List<Source> {
		var trace: List<Source>;
		for (i = sp - 1; i >= 0; i--) {
			var f = stack[i];
			var source: Source;
			if (SsaApplyOp.?(f.ip)) source = SsaApplyOp.!(f.ip).source;
			trace = List.new(source, trace);
		}
		return Lists.reverse(trace);
	}
	def pushFrame(spec: IrSpec, recvr: Val, args: Range<Val>) {
		if (printer != null) {
			var b = printer.buf;
			for (j < sp) b.puts("  ");
			b.puts("=>");
			b.red().put1("#%d", spec.member.uid).end().sp();
			b.green().put1("%q", spec.render).end();
			b.putc('(');
		}
		var prev = frame;
		if (sp >= stack.length) stack = Arrays.grow(stack, stack.length * 4);
		frame = stack[sp];
		if (frame == null) frame = stack[sp] = SsaIntFrame.new();
		sp++;
		frame.meth = spec.asMethod();
		frame.spec = spec;
		var ssa = frame.meth.ssa;
		if (ssa == null) ssa = genSsa(spec, 0);
		frame.block = ssa.startBlock;
		frame.ip = nextInstr(ssa.startBlock);
		if (prev != null) frame.fp = prev.fp + prev.meth.ssa.numValues;
		setVal(ssa.params[0], recvr);
		if (printer != null) {
			var param = ssa.params[0];
			printer.buf.putref(param);
			printer.buf.puts("=");
			printer.buf.putv(recvr, param.getType());
		}
		for (i = 1; i < ssa.params.length; i++) {
			var param = ssa.params[i], arg = args[i - 1];
			setVal(param, arg);
			if (printer != null) {
				printer.buf.csp();
				printer.buf.putref(param);
				printer.buf.puts("=");
				printer.buf.putv(arg, param.getType());
			}
		}
		if (printer != null) {
			printer.buf.puts(")");
			printer.outln();
		}
	}
	def popFrame() -> SsaIntFrame {
		sp--;
		if (sp < 1) return frame = null;
		return frame = stack[sp - 1];
	}
	def unwind() {
		frame = null;
		sp = 0;
	}
}
class SsaIntArguments(prog: Program) extends Arguments {
	var frame: SsaIntFrame;
	var args: Array<Val> = Array.new(INITIAL_VALUES);
	var nargs: int;
	var typeArgs: Array<Type>;
	var interpreter: SsaInterpreter;

	def numArgs() -> int {
		return nargs;
	}
	def getArg(i: int) -> Val {
		return args[i];
	}
	def getType(i: int) -> Type {
		var t = typeArgs[i];
		if (t.open()) t = frame.spec.instantiateType(t);
		return t;
	}
	def getTypes() -> Array<Type> {
		return frame.spec.instantiateTypes(typeArgs);
	}
	def getProgram() -> Program {
		return prog;
	}
	def tailCall(spec: IrSpec, recvr: Val, startArg: int, endArg: int) -> Result {
		if (interpreter.printer != null) {
			interpreter.printer.buf.put1("tail-call(%q)", spec.render);
			interpreter.printer.outln();
		}
		if (spec == null) {
			return interpreter.exception = Exception.new(V3Exception.NullCheck, "null function", interpreter.getStackTrace());
		} else {
			interpreter.tailCalled = true;
			interpreter.pushFrame(spec, recvr, args[startArg ... endArg]);
			return null;
		}
	}
	def throw(ex: string, msg: string) -> Exception {
		var e = interpreter.exception = Exception.new(ex, msg, interpreter.getStackTrace());
		interpreter.unwind();
		return e;
	}
}
class SsaIntFrame {
	var spec: IrSpec;
	var meth: IrMethod;
	var block: SsaBlock;
	var ip: SsaInstr;
	var fp: int;
}
